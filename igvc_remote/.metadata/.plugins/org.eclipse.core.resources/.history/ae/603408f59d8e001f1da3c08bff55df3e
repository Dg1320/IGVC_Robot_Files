/*
 * my_wheel_ops.c
 *
 *  Created on: Mar 30, 2024
 *      Author: clutch13
 */

#include <stdint.h>
#include <stdbool.h>

#include "remote_control.h"
#include "tm4c123gh6pm.h"
#include "uart0.h"
#include "my_wheel_ops.h"
#include "pwm_init.h"


int32_t right_pwm = 0;
int32_t left_pwm = 0;

bool check_is_something_infront_of_me = false;

extern bool valid;
extern bool forward;
extern bool reverse;
extern bool cw;
extern bool ccw;
extern bool stop;


#define RIGHT_RECIEVER  0b00000010
#define LEFT_RECIEVER   0b00000001

//#define DEBUG


void go_forward ( int8_t speed)
{

               switch(speed)                                 // control speed--- thousand millimeters per minute
            {

                case 2:
                        left_pwm = 770-5;
                        right_pwm = 770;
                        setpwm(left_pwm, 0, right_pwm, 0);
                        break;

                case 3: left_pwm = 820-5;
                        right_pwm = 820;
                        setpwm(left_pwm, 0, right_pwm, 0);
                        break;

                case 4: left_pwm = 870-5;
                        right_pwm = 870;
                        setpwm(left_pwm, 0, right_pwm, 0);
                        break;

                case 5: left_pwm = 920-5;
                        right_pwm = 920;
                        setpwm(left_pwm, 0, right_pwm, 0);
                        break;

                case 6: left_pwm = 970-5;
                        right_pwm = 970;
                        setpwm(left_pwm, 0, right_pwm, 0);
                        break;

                case 7: left_pwm = 1018-5;
                        right_pwm = 1018;
                        setpwm(left_pwm, 0, right_pwm, 0);
                        break;


                default: left_pwm = 1018-5;
                        right_pwm = 1018;
                        setpwm(left_pwm, 0, right_pwm, 0);

            }




}

void go_backwards( int8_t speed )
{

               switch(speed)                                 // control speed--- thousand millimeters per minute
            {
                        case 2:
                                left_pwm = 770-25;
                                right_pwm = 770;
                                setpwm(0, left_pwm, 0, right_pwm);
                                break;

                        case 3: left_pwm = 825-25;
                                right_pwm = 825;
                                setpwm(0, left_pwm, 0, right_pwm);
                                break;

                        case 4: left_pwm = 875-25;
                                right_pwm = 875;
                                setpwm(0, left_pwm, 0, right_pwm);
                                break;

                        case 5: left_pwm = 935-25;
                                right_pwm = 935;
                                setpwm(0, left_pwm, 0, right_pwm);
                                break;

                        case 6: left_pwm = 980-25;
                                right_pwm = 980;
                                setpwm(0, left_pwm, 0, right_pwm);
                                break;

                        case 7: left_pwm = 1018-25;
                                right_pwm = 1018;
                                setpwm(0, left_pwm, 0, right_pwm);
                                break;

                        default: left_pwm = 1018-25;
                                right_pwm = 1018;
                                setpwm(0, left_pwm, 0, right_pwm);

            }




}

void go_clockwise( void )
{

                left_pwm = 970-5;
                right_pwm = 970;
                setpwm(left_pwm, 0, 0, right_pwm);


}

void go_counter_clockwise (void)
{
            left_pwm = 970-5;
            right_pwm = 970;
            setpwm(0, left_pwm, right_pwm, 0);


}

void lets_stop (void)
{
            valid = true;
            stop = true;
            cw = false;
            ccw = false;
            forward = false;
            reverse = false;

            // change the compare values to make the motors stop
            setpwm(1,1,1,1);

            H_BRIDGE_MODE = 0;

            left_wheel_count = 0;            // allow the wheel correction method to stop running
            right_wheel_count = 0;

            putsUart0("Stoping NOW\n...\n..\n.\n");

}

void new_wheelcount(void)
{

                valid = true;

                left_wheel_count = 0;

                right_wheel_count = 0;

                putsUart0("Clearing Wheel Count\n...\n..\n.\n");
}

void print_wheels_info( int16_t L_count, int16_t R_count, char *L_print, char *R_print)
{

            int_to_ascii(R_count , R_print);
            int_to_ascii(L_count , L_print);
//            int_to_ascii(R_count - L_count , count_difference_R);

            putsUart0("Right:");
            putsUart0(R_print);

            putsUart0("\n");

            putsUart0("Left :");
            putsUart0(L_print);

            putsUart0("\n");
             putsUart0("\n");

//
//            putsUart0("                      Count Difference :");
//            putsUart0(count_difference_R);
//            putsUart0("\n");


}

void test_forward(int8_t speed)
{
                valid = true;
                forward = true;

                reverse = false;
                cw = false;
                ccw = false;
                stop = false;


                left_wheel_count = 0;

                right_wheel_count = 0;


               switch(speed)                                 // control speed--- thousand millimeters per minute
            {
                case 2: setpwm(750-11, 0, 750, 0);
                        break;

                case 3: setpwm(780-11, 0, 780, 0);
                        break;

                case 4: setpwm(810-11, 0, 810, 0);
                        break;

                case 5: setpwm(870-11, 0, 870, 0);

                        break;

                case 6: setpwm(900-11, 0, 900, 0);
                        break;

                case 7: setpwm(950-11, 0, 950, 0);
                        break;

                case 8: setpwm(990-11, 0, 990, 0);
                        break;

                case 9: setpwm(1015-11, 0, 1015, 0);
                        break;

                default: setpwm(1015-11, 0, 1015, 0);

            }


                                                // run for 3 seconds then stop

              //  print_wheels_info( left_wheel_count, right_wheel_count, count_to_screen_L,count_to_screen_R);


}

void Right_Wheel_one_shot_ISR(void)
{

     GPIO_PORTD_IM_R |= RIGHT_RECIEVER ;     // turn back on interrupt mask

     TIMER2_ICR_R = TIMER_ICR_TATOCINT;           // clear interrupt flag
     TIMER2_CTL_R &= ~TIMER_CTL_TAEN;             // turn-off timer
    // DEBUG_PORTE2 ^=1;

}

void Left_Wheel_one_shot_ISR(void)
{



    GPIO_PORTD_IM_R |=  LEFT_RECIEVER;     // turn back on interrupt mask

    WTIMER5_ICR_R = TIMER_ICR_TATOCINT;           // clear interrupt flag
    WTIMER5_CTL_R &= ~TIMER_CTL_TAEN;             // turn-off timer


}

void distance_check_ISR(void)
{

            setpwm(0,0,0,0);
            WTIMER3_ICR_R = TIMER_ICR_TATOCINT;           // clear interrupt flag
            WTIMER3_CTL_R &= ~TIMER_CTL_TAEN;             // turn-off timer
            putsUart0("\nFinished Running Requested Distance... ");
            putsUart0("\n");

}
