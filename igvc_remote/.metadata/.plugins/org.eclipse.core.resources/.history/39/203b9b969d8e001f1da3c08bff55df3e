/*
 * my_wheel_ops.c
 *
 *  Created on: Mar 30, 2024
 *      Author: clutch13
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>

#include "remote_control.h"
#include "tm4c123gh6pm.h"
#include "uart0.h"
#include "my_wheel_ops.h"
#include "pwm_init.h"


int32_t right_pwm = 0;
int32_t left_pwm = 0;

uint8_t tocheck = 0;
uint8_t go_to = 0 ;
bool already_done_this_one = false;
bool self_drive = false;
bool go_ahead = true;
bool check_is_something_infront_of_me = false;
extern  int32_t distance;
extern uint8_t gohere;

extern bool valid;
extern bool forward;
extern bool reverse;
extern bool cw;
extern bool ccw;
extern bool stop;


extern uint32_t ultra_sonic_distances [8];
extern uint32_t ultrasonic_distance;


#define RIGHT_RECIEVER  0b00000010
#define LEFT_RECIEVER   0b00000001

//#define DEBUG

void wheel_readings_setup(void)
{
    GPIO_PORTD_DIR_R &=  ~(RIGHT_RECIEVER | LEFT_RECIEVER);  // PD[1] and PD[0] are inputs   // IR LED's
    GPIO_PORTD_DEN_R |= RIGHT_RECIEVER | LEFT_RECIEVER ;
    GPIO_PORTD_PDR_R |= RIGHT_RECIEVER | LEFT_RECIEVER ;                 // enable internal pull-down resistors

    // set up interrupt
    GPIO_PORTD_IM_R &= ~(RIGHT_RECIEVER | LEFT_RECIEVER);     // clear interrupt mask to prevent false interrupts
    GPIO_PORTD_IS_R &= ~(RIGHT_RECIEVER | LEFT_RECIEVER); // Make edge sensitive
    GPIO_PORTD_IBE_R |= RIGHT_RECIEVER | LEFT_RECIEVER;  // Turn on both edge detecting sense ** better distance accuracy **
    //GPIO_PORTD_IBE_R &= ~(RIGHT_RECIEVER | LEFT_RECIEVER); // Turn off both edge detecting sense
    //GPIO_PORTD_IEV_R &= ~(RIGHT_RECIEVER | LEFT_RECIEVER); // Make detect falling edge
    GPIO_PORTD_ICR_R |= RIGHT_RECIEVER | LEFT_RECIEVER;     // clear the interrupts
    GPIO_PORTD_IM_R |= RIGHT_RECIEVER | LEFT_RECIEVER;     // turn on interrupt mask

    NVIC_EN0_R = 1 << (INT_GPIOD-16);                // turn-on interrupt 19 (GPIOD)

}

void reading_wheels(void)
{

        forward_wheel_balance ();
        reverse_wheel_balance();
       clockwise_wheel_balance();
       counter_clockwise_wheel_balance();

         if(GPIO_PORTD_MIS_R & RIGHT_RECIEVER)       // left reciever
        {
                right_wheel_count++;

                GPIO_PORTD_IM_R &= ~RIGHT_RECIEVER;     // turn off interrupt mask
                TIMER2_CTL_R |= TIMER_CTL_TAEN;         // turn-on one shot timer



        }


        if(GPIO_PORTD_MIS_R & LEFT_RECIEVER)       // left reciever
        {
                left_wheel_count++;
                if(reverse)
                {
                    if((left_wheel_count % 8) == 0)    BLUE_LED  ^= 1;                    // WHEN INTERRUPT OCCUR TOGGLE LED
                }
                else BLUE_LED = 0;

                GPIO_PORTD_IM_R &= ~LEFT_RECIEVER;     // turn off interrupt mask
                WTIMER5_CTL_R |= TIMER_CTL_TAEN;         // turn-on one shot timer ... (count down then interrupt)

        }



       GPIO_PORTD_ICR_R |= RIGHT_RECIEVER | LEFT_RECIEVER;       // clear the interrupt flag

#ifdef DEBUG
      print_wheels_info( left_wheel_count, right_wheel_count, count_to_screen_L,count_to_screen_R);
#endif


          if(distance && (forward || reverse) && valid)
               {
                       if( right_wheel_count  > distance)         // are you performing a distance operation?
                       {

                               setpwm(0,0,0,0);
                               stop = true;
                               distance = 0;
                               waitMicrosecond(2000000);

                              while(MOTION_DETECTED)
                                  {
                                       putsUart0("motion\n");
                                       GREEN_LED = 1;
                                       waitMicrosecond(250000);
                                       GREEN_LED = 0;
                                       waitMicrosecond(250000);

                                  };

                               go_ahead = true;
                               check_is_something_infront_of_me = false;
                       }

               }

           if(distance && (ccw || cw))
               {

                   if(right_wheel_count > distance)         // are you performing a distance operation?
                   {

                       setpwm(1,1,1,1);
                       stop = true;
                       distance = 0;

                       trigger_ultrasonic();
                   }
                   if(go_ahead == false && !distance )
                   {
                       waitMicrosecond(500000);                     // pause real quick then go
                       distance = ultra_sonic_distances [go_to];
                       distance = distance/14;

                       if(already_done_this_one)
                       {
                       distance /= 2;                               // go half the distance to the location
                       already_done_this_one = false;
                       }
                       else if (!already_done_this_one)
                       {
                           distance /= 1.5;
                           already_done_this_one = true;
                       }

                       go_forward(100);

                       check_is_something_infront_of_me = true;
                   }
               }


                    if(check_is_something_infront_of_me)
                    {
                        if ((right_wheel_count % 3) == 0)
                        {
                            trigger_ultrasonic();

                        }


                    }
}



void go_forward ( int8_t speed)
{
                valid = true;
                forward = true;

                reverse = false;
                cw = false;
                ccw = false;
                stop = false;


               left_wheel_count = 0;            // zero out values for accurate straight traveling
               right_wheel_count = 0;

                 if(distance > 3)
                 {
                     distance-= 1;   // callibration
                 }
                 H_BRIDGE_MODE = 1;

               switch(speed)                                 // control speed--- thousand millimeters per minute
            {

                case 2:
                        left_pwm = 770-5;
                        right_pwm = 770;
                        setpwm(left_pwm, 0, right_pwm, 0);
                        break;

                case 3: left_pwm = 820-5;
                        right_pwm = 820;
                        setpwm(left_pwm, 0, right_pwm, 0);
                        break;

                case 4: left_pwm = 870-5;
                        right_pwm = 870;
                        setpwm(left_pwm, 0, right_pwm, 0);
                        break;

                case 5: left_pwm = 920-5;
                        right_pwm = 920;
                        setpwm(left_pwm, 0, right_pwm, 0);
                        break;

                case 6: left_pwm = 970-5;
                        right_pwm = 970;
                        setpwm(left_pwm, 0, right_pwm, 0);
                        break;

                case 7: left_pwm = 1018-5;
                        right_pwm = 1018;
                        setpwm(left_pwm, 0, right_pwm, 0);
                        break;


                default: left_pwm = 1018-5;
                        right_pwm = 1018;
                        setpwm(left_pwm, 0, right_pwm, 0);

            }




}

void go_backwards( int8_t speed )
{

                valid = true;
                reverse = true;

                cw = false;
                ccw = false;
                forward = false;
                stop = false;

               left_wheel_count = 0;            // zero out values for accurate straight traveling
               right_wheel_count = 0;

               H_BRIDGE_MODE = 1;

               switch(speed)                                 // control speed--- thousand millimeters per minute
            {
                        case 2:
                                left_pwm = 770-25;
                                right_pwm = 770;
                                setpwm(0, left_pwm, 0, right_pwm);
                                break;

                        case 3: left_pwm = 825-25;
                                right_pwm = 825;
                                setpwm(0, left_pwm, 0, right_pwm);
                                break;

                        case 4: left_pwm = 875-25;
                                right_pwm = 875;
                                setpwm(0, left_pwm, 0, right_pwm);
                                break;

                        case 5: left_pwm = 935-25;
                                right_pwm = 935;
                                setpwm(0, left_pwm, 0, right_pwm);
                                break;

                        case 6: left_pwm = 980-25;
                                right_pwm = 980;
                                setpwm(0, left_pwm, 0, right_pwm);
                                break;

                        case 7: left_pwm = 1018-25;
                                right_pwm = 1018;
                                setpwm(0, left_pwm, 0, right_pwm);
                                break;

                        default: left_pwm = 1018-25;
                                right_pwm = 1018;
                                setpwm(0, left_pwm, 0, right_pwm);

            }




}

void go_clockwise( void )
{
            valid = true;
            cw = true;
            ccw = false;
            forward = false;
            reverse = false;
            stop = false;
            // change the compare values to make the motors turn clockwise

               left_wheel_count = 0;

                right_wheel_count = 0;

               H_BRIDGE_MODE = 1;

                left_pwm = 970-5;
                right_pwm = 970;
                setpwm(left_pwm, 0, 0, right_pwm);


}

void go_counter_clockwise (void)
{
            valid = true;
            cw = false;
            ccw = true;
            forward = false;
            reverse = false;
            stop = false;

            left_wheel_count = 0;

            right_wheel_count = 0;

            H_BRIDGE_MODE = 1;

            left_pwm = 970-5;
            right_pwm = 970;
            setpwm(0, left_pwm, right_pwm, 0);


}

void lets_stop (void)
{
            valid = true;
            stop = true;
            cw = false;
            ccw = false;
            forward = false;
            reverse = false;

            // change the compare values to make the motors stop
            setpwm(1,1,1,1);

            H_BRIDGE_MODE = 0;

            left_wheel_count = 0;            // allow the wheel correction method to stop running
            right_wheel_count = 0;

            putsUart0("Stoping NOW\n...\n..\n.\n");

}

void new_wheelcount(void)
{

                valid = true;

                left_wheel_count = 0;

                right_wheel_count = 0;

                putsUart0("Clearing Wheel Count\n...\n..\n.\n");
}

void print_wheels_info( int16_t L_count, int16_t R_count, char *L_print, char *R_print)
{

            int_to_ascii(R_count , R_print);
            int_to_ascii(L_count , L_print);
//            int_to_ascii(R_count - L_count , count_difference_R);

            putsUart0("Right:");
            putsUart0(R_print);

            putsUart0("\n");

            putsUart0("Left :");
            putsUart0(L_print);

            putsUart0("\n");
             putsUart0("\n");

//
//            putsUart0("                      Count Difference :");
//            putsUart0(count_difference_R);
//            putsUart0("\n");


}

void test_forward(int8_t speed)
{
                valid = true;
                forward = true;

                reverse = false;
                cw = false;
                ccw = false;
                stop = false;


                left_wheel_count = 0;

                right_wheel_count = 0;


               switch(speed)                                 // control speed--- thousand millimeters per minute
            {
                case 2: setpwm(750-11, 0, 750, 0);
                        break;

                case 3: setpwm(780-11, 0, 780, 0);
                        break;

                case 4: setpwm(810-11, 0, 810, 0);
                        break;

                case 5: setpwm(870-11, 0, 870, 0);

                        break;

                case 6: setpwm(900-11, 0, 900, 0);
                        break;

                case 7: setpwm(950-11, 0, 950, 0);
                        break;

                case 8: setpwm(990-11, 0, 990, 0);
                        break;

                case 9: setpwm(1015-11, 0, 1015, 0);
                        break;

                default: setpwm(1015-11, 0, 1015, 0);

            }


                                                // run for 3 seconds then stop

              //  print_wheels_info( left_wheel_count, right_wheel_count, count_to_screen_L,count_to_screen_R);


}

void Right_Wheel_one_shot_ISR(void)
{

     GPIO_PORTD_IM_R |= RIGHT_RECIEVER ;     // turn back on interrupt mask

     TIMER2_ICR_R = TIMER_ICR_TATOCINT;           // clear interrupt flag
     TIMER2_CTL_R &= ~TIMER_CTL_TAEN;             // turn-off timer
    // DEBUG_PORTE2 ^=1;

}

void Left_Wheel_one_shot_ISR(void)
{



    GPIO_PORTD_IM_R |=  LEFT_RECIEVER;     // turn back on interrupt mask

    WTIMER5_ICR_R = TIMER_ICR_TATOCINT;           // clear interrupt flag
    WTIMER5_CTL_R &= ~TIMER_CTL_TAEN;             // turn-off timer


}

void distance_check_ISR(void)
{

            setpwm(0,0,0,0);
            WTIMER3_ICR_R = TIMER_ICR_TATOCINT;           // clear interrupt flag
            WTIMER3_CTL_R &= ~TIMER_CTL_TAEN;             // turn-off timer
            putsUart0("\nFinished Running Requested Distance... ");
            putsUart0("\n");

}
